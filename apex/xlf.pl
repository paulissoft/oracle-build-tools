#!/usr/bin/env perl

#/usr/bin/env perl

=pod

=head1 NAME

xlf.pl - Check a XML dictionary (no XLIFF file) or convert XLIFF file(s) using the XML dictionary.

=head1 SYNOPSIS

perl xlf.pl [-h] [-l <language>] [-x <XML dictionary> ] [-v] [XLIFF file(s)]

=head1 DESCRIPTION

XLIFF is a standard to translate documents.

=head2 An example XML dictionary

If the XML dictionary does not have a target for a source, the source in the XLIFF file is not replaced.

  <?xml version="1.0" encoding="UTF-8"?>
  <xliff version="1.0">
    <trans-unit>
      <source>Impression Friendly</source>
      <target>Impression rapide</target>
    </trans-unit>
    <trans-unit>
      <source>Info</source>
    </trans-unit>
    ...
  </xliff>

=head2 An example XLIFF file

  <?xml version="1.0" encoding="UTF-8"?>
  <!-- 
    ****************** 
    ** Source     :  101
    ** Source Lang:  en
    ** Target     :  121
    ** Target Lang:  fr
    ** Filename:     f101_121_en_fr.xlf
    ** Generated By: ADMIN
    ** Date:         28-APR-2020 12:35:35
    ****************** 
   -->
  <xliff version="1.0">
    <file original="f101_121_en_fr.xlf" source-language="en" target-language="fr" datatype="html">
      <header></header>
      <body>
        <trans-unit id="S-2-173785385642816546-101">
          <source>Info</source>
          <target>Info</target>
        </trans-unit>
      ...
      </body>
    </file>
  </xliff>

=head1 OPTIONS

=over 4

=item B<--help>

This help.

=item B<--language>

Use this language to convert. Default (fr)ench.

=item B<--xml-dictionary>

The XML dictionary. By default xlf_${language}.xml.

=item B<--verbose>

Increasing the verbosity.

=back

=head1 NOTES

=head1 EXAMPLES

=head1 BUGS

=head1 SEE ALSO

=head1 AUTHOR

Gert-Jan Paulissen, E<lt>gert.jan.paulissen@gmail.comE<gt>.

=head1 VERSION

$Header$

=head1 HISTORY

=cut

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use XML::Twig;

my $language = 'fr';
my $xml_dict = undef;
my $verbose = 0;

# prototypes
sub main ();
sub parse_command_line ();
sub warning ($);
sub info ($);
sub read_xml_dictionary ($);
sub check_xml_dictionary ($);
sub process_xliff_translation_file ($$);
sub translate_target ($$$$$);

main();

sub main () {
    # Windows FTYPE and ASSOC cause the command 'textrepl  -h -c file'
    # to have ARGV[0] == '  -h -c file' and number of arguments 1.
    # Hence strip the spaces from $ARGV[0] and recreate @ARGV.
    if ( @ARGV == 1 && $ARGV[0] =~ s/^\s+//o ) {
        @ARGV = split( / /, $ARGV[0] );
    }

    parse_command_line();
    
    if (@ARGV == 0) {
        info("Checking XML dictionary $xml_dict");
        
        check_xml_dictionary($language);
    } else {
        foreach my $argv (@ARGV) {
            info("Converting $argv using XML dictionary $xml_dict");
            
            process_xliff_translation_file($argv, $language);
        }
    }
}

sub parse_command_line () {
    Getopt::Long::Configure(qw(require_order));

    #
    GetOptions('language=s' => \$language,
               'xml-dictionary=s' => \$xml_dict,
               'help' => sub { pod2usage(-verbose => 2) },
               'verbose+' => \$verbose
        )
        or pod2usage(-verbose => 0);

    if (!defined($xml_dict)) {
        $xml_dict = "xlf_${language}.xml";
    }
    
    if (! -f $xml_dict) {
        warning("Creating $xml_dict");
        
        open(my $fh, ">$xml_dict") || die "Can not write to $xml_dict: $!";
        print $fh '<?xml version="1.0" encoding="UTF-8"?><xliff version="1.0"></xliff>';
        $fh->close();
    }
        
} # parse_command_line

sub warning ($) {
    print STDERR "WARNING: $_[0]\n";
}
    
sub info ($) {
    print STDERR "INFO: $_[0]\n"
        if ($verbose > 0);
}

sub read_xml_dictionary ($) {
    # EXAMPLE:
    #
    # <?xml version="1.0" encoding="UTF-8"?>
    # <xliff version="1.0">
    #   <trans-unit>
    #     <source>Impression Friendly</source>
    #     <target>Impression conviviale</target>
    #   </trans-unit>
    #   <trans-unit>
    #     <source>Info</source>
    #   </trans-unit>
    # </xliff>
    #
    # The second trans-unit element means that this source needs no translation (NEVER).
    #
    my ($language) = (@_);

    my $twig_dict = new XML::Twig(twig_roots => { 'trans-unit' => 1 });

    $twig_dict->parsefile($xml_dict);    # build the twig

    my %dict; # dictionary of source (key) and target (value)

    foreach my $trans_unit ($twig_dict->root->children) {
        my ($source, $target) = $trans_unit->children;

        if (!exists($dict{$source->text})) {
            $dict{$source->text} = (defined($target) ? $target->text : undef);
        }
    }

    return ($twig_dict, $xml_dict, \%dict);
}

sub check_xml_dictionary ($) {
    my (undef, undef, $r_dict) = read_xml_dictionary($_[0]);

    foreach my $key (sort keys %$r_dict) {
        if (defined($r_dict->{$key}) && $key eq $r_dict->{$key}) {
            warn "*** SOURCE and TARGET equal ***\n$key\n\n";
        }
    }
}
    
sub process_xliff_translation_file ($$) {
    # EXAMPLE:
    #
    # <?xml version="1.0" encoding="UTF-8"?>
    # <!-- 
    #   ****************** 
    #   ** Source     :  101
    #   ** Source Lang:  en
    #   ** Target     :  104
    #   ** Target Lang:  fr
    #   ** Filename:     f101_104_en_fr.xlf
    #   ** Generated By: ADMIN
    #   ** Date:         07-FEB-2020 13:30:35
    #   ****************** 
    #  -->
    # <xliff version="1.0">
    # <file original="f101_104_en_fr.xlf" source-language="en" target-language="fr" datatype="html">
    # <header></header>
    # <body>
    # <trans-unit id="S-2-137935716080920667-101">
    # <source>Impression Friendly</source>
    # <target>Impression conviviale</target>
    # </trans-unit>
    # ...
    # </body>
    # </file>
    # </xliff>
    #
    my $xliff_file = shift @_;

    my ($twig_dict, $xml_dict, $r_dict);
        
    ($twig_dict, $xml_dict, $r_dict) = read_xml_dictionary(shift @_);

    my $added = 0;

    # Create a closure to capture $r_dict
    my $twig_file = new XML::Twig(twig_handlers => { 'trans-unit' => sub { translate_target($twig_dict, $r_dict, \$added, $_[0], $_[1]); } });

    $twig_file->parsefile($xliff_file);    # build the twig

    if ($added) {
        rename($xml_dict, "$xml_dict.bak") == 1 || die "Can not rename $xml_dict to $xml_dict.bak";
        $twig_dict->set_pretty_print('indented');
        $twig_dict->print_to_file($xml_dict);
    }

    rename($xliff_file, "$xliff_file.bak") == 1 || die "Can not rename $xliff_file to $xliff_file.bak";
    $twig_file->set_pretty_print('nice');
    $twig_file->print_to_file($xliff_file);
}    

sub translate_target ($$$$$) {
    my ($twig_dict, $r_dict, $r_added, $twig_file, $trans_unit) = @_;

    my ($source, $target) = $trans_unit->children;

    if (!exists($r_dict->{$source->text})) {
        warning(sprintf("Adding XLF source '%s' and target '%s' to XML dictionary.", $source->text, $target->text));
        
        $r_dict->{$source->text} = $target->text;

        # Adding it to the Twig dictionary
        my $trans_unit_copy = $trans_unit->copy;
    
        $trans_unit_copy->del_att('id');
        $trans_unit_copy->paste(last_child => $twig_dict->root);

        $$r_added = 1;
    } elsif (defined($r_dict->{$source->text}) && $r_dict->{$source->text} ne $target->text) {
        info(sprintf("Changing target text for XLF source '%s' and target '%s' to XML dictionary target '%s'.",
                     $source->text,
                     $target->text,
                     $r_dict->{$source->text}));
        
        $target->set_text($r_dict->{$source->text});
    } elsif (!defined($r_dict->{$source->text}) && $source->text eq $target->text) {
        info(sprintf("Leaving XLF source '%s' with same target unchanged since the XML dictionary source is not defined.",
                     $source->text));
    } elsif (!defined($r_dict->{$source->text})) {
        info(sprintf("Changing XLF target '%s' to source '%s' since there is no XML dictionary target.\n",
                     $target->text,
                     $source->text));
        
        $target->set_text($source->text);
    }
}
