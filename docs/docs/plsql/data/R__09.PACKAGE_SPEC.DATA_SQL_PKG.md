<!-- DO NOT EDIT THIS FILE DIRECTLY - it is generated from source file db/app/data/src/full/R__09.PACKAGE_SPEC.DATA_SQL_PKG.sql -->
<!-- markdownlint-disable MD003 MD012 MD024 MD033 -->

- [Package "DATA_SQL_PKG"](#package-data_sql_pkg)
- [Type statement_tab_t](#type-statement_tab_t)
- [Type row_count_tab_t](#type-row_count_tab_t)
- [Procedure do](#procedure-do)
- [Procedure do](#procedure-do-1)
- [Function get_column_info](#function-get_column_info)
- [Procedure set_column_value](#procedure-set_column_value)
- [Procedure construct_statement](#procedure-construct_statement)
- [Procedure print](#procedure-print)
- [Procedure print](#procedure-print-1)


# Package "DATA_SQL_PKG"

Use dynamic SQL to retrieve data as either scalars or arrays by using SYS.ANYDATA.
It is essentially created to enable SQL on a set of related tables, i.e. tables with a foreign key relation.

Only (scalar and array) types supported by DBMS_SQL and ANYDATA are supported by this package.

Scalar data types supported:

| SQL data type                     | Convert to anydata function | ANYDATA type                |
| :------------                     | :-------------------------- | :-----------                |
| CLOB                              | anydata.ConvertClob         | SYS.CLOB                    |               
| BINARY_FLOAT                      | anydata.ConvertBFloat       | SYS.BINARY_FLOAT            |
| BINARY_DOUBLE                     | anydata.ConvertBDouble      | SYS.BINARY_DOUBLE           |
| BLOB                              | anydata.ConvertBlob         | SYS.BLOB                    |
| BFILE                             | anydata.ConvertBfile        | SYS.BFILE                   |
| DATE                              | anydata.ConvertDate         | SYS.DATE                    |
| NUMBER                            | anydata.ConvertNumber       | SYS.NUMBER                  |
| UROWID                            | anydata.ConvertURowid       | SYS.UROWID                  |
| VARCHAR2                          | anydata.ConvertVarchar2     | SYS.VARCHAR2                |
| TIMESTAMP                         | anydata.ConvertTimestamp    | SYS.TIMESTAMP               |
| TIMESTAMP(6) WITH LOCAL TIME ZONE | anydata.ConvertTimestampLTZ | SYS.TIMESTAMP_WITH_LTZ      |
| TIMESTAMP(6) WITH TIME ZONE       | anydata.ConvertTimestampTZ  | SYS.TIMESTAMP_WITH_TIMEZONE |
| INTERVAL DAY(2) TO SECOND(6)      | anydata.ConvertIntervalDS   | SYS.INTERVAL_DAY_SECOND     |
| INTERVAL YEAR(2) TO MONTH         | anydata.ConvertIntervalYM   | SYS.INTERVAL_YEAR_MONTH     |

 
Array types supported (see 1 below for PL/SQL type names):
- SYS.CLOB_TABLE
- SYS.BINARY_FLOAT_TABLE
- SYS.BINARY_DOUBLE_TABLE
- SYS.BLOB_TABLE
- SYS.BFILE_TABLE
- SYS.DATE_TABLE
- SYS.NUMBER_TABLE
- SYS.UROWID_TABLE
- SYS.VARCHAR2_TABLE
- SYS.TIMESTAMP_TABLE
- SYS.TIMESTAMP_WITH_LTZ_TABLE
- SYS.TIMESTAMP_WITH_TIME_ZONE_TABLE (see 2)
- SYS.INTERVAL_DAY_TO_SECOND_TABLE (see 3)
- SYS.INTERVAL_YEAR_TO_MONTH_TABLE (see 4)

PL/SQL type names (not supported in SQL!):
1. Please note that it is usually the anydata scalar type name with '_TABLE' as suffix but with some exceptions:
2. Not SYS.TIMESTAMP_WITH_TIMEZONE_TABLE
3. Not SYS.INTERVAL_DAY_SECOND_TABLE
4. Not SYS.INTERVAL_YEAR_MONTH_TABLE

In PL/SQL you replace SYS. by DBMS_SQL. (they are all defined there), so DBMS_SQL.CLOB_TABLE, DBMS_SQL.BINARY_FLOAT_TABLE and so on.
 
This package has AUTHID CURRENT_USER so that it can be used by 
any schema to which this package has been granted.

SIGNATURE

```sql
PACKAGE "DATA_SQL_PKG" authid current_user is

-- 0: no debugging; 1: normal; 2: extra
c_debugging constant naturaln := $if cfg_pkg.c_debugging $then 0 $else 0 $end;

-- SYS.STANDARD defines TIME_UNCONSTRAINED and TIME_TZ_UNCONSTRAINED but there is no anydata.Convert* function for it.
c_support_time constant boolean := false;

-- ORA-03001: unimplemented feature
e_unimplemented_feature exception;
pragma exception_init(e_unimplemented_feature, -3001);
```


## Type statement_tab_t

Sometimes a parent or child table may have a selection not so simple as "select * from <table>".

SIGNATURE

```sql
type statement_tab_t is table of statement_t index by all_tab_columns.table_name%type;
```


## Type row_count_tab_t

Input: specify the maximum row count to fetch for a table. Output: the number of rows retrieved / processed.

SIGNATURE

```sql
type row_count_tab_t is table of natural index by all_tab_columns.table_name%type;
```


## Procedure do

Perform SQL for a single table.

The input value for p_row_count determines how and how much rows is retrieved for a query (select):
- when 1: select just a single row (and raise exceptions no_data_found / too_many_rows when no or more than 1 row is fetched) and store them in scalars
- when null: unlimited number of fetches and store them in arrays (even though at most 1 row may be fetched)
- when greater than 1: fetch at most this amount of rows and store them in arrays (even though at most 1 row may be fetched)

SIGNATURE

```sql
procedure do
( p_operation in varchar2 -- (S)elect, (I)nsert, (U)pdate, (M)erge or (D)elete
, p_table_name in varchar2 -- the table name
, p_bind_variable_tab in column_value_tab_t default empty_column_value_tab -- only when an entry exists that table column will be used in the query or DML
, p_statement in statement_t default null -- if null it will default to 'select * from <table>' for a (S)elect
, p_order_by in varchar2 default null -- to be added after the (default) query (without ORDER BY)
, p_owner in varchar2 default user -- the owner of the table
, p_row_count in out nocopy natural
, p_column_value_tab in out nocopy column_value_tab_t -- only when an entry exists that table column will be used in the query or DML
);
```


## Procedure do

Perform SQL for a set of related tables.

SIGNATURE

```sql
procedure do
( p_operation in varchar2 -- (S)elect, (I)nsert, (U)pdate, (M)erge or (D)elete
, p_parent_table_name in varchar2 -- we must start with this
, p_table_bind_variable_tab in table_column_value_tab_t -- only when an entry exists that table column will be used in the query or DML
, p_statement_tab in statement_tab_t default empty_statement_tab -- per table a query (if any): if none or null it will default to 'select * from <table>' for a (S)elect
, p_order_by_tab in statement_tab_t default empty_statement_tab -- per table an order by (if any)
, p_owner in varchar2 default user -- the owner of the table(s)
, p_row_count_tab in out nocopy row_count_tab_t -- per table a max row count (if any) on input
, p_table_column_value_tab in out nocopy table_column_value_tab_t -- only when an entry exists that table column will be used in the query or DML
);
```


## Function get_column_info

Get column information for a table.

SIGNATURE

```sql
function get_column_info
( p_owner in all_tab_columns.owner%type
, p_table_name in all_tab_columns.table_name%type
, p_column_name_list in all_tab_columns.column_name%type default '%' -- comma separated list of column names (wildcards allowed)
)
return column_info_tab_t
pipelined;
```


## Procedure set_column_value

Set a column value.

SIGNATURE

```sql
procedure set_column_value
( p_data_type in all_tab_columns.data_type%type default null -- determines which field records are valid
, p_is_table in boolean default false -- determines whether the scalar (FALSE) or array variant (TRUE) is valid
, p_clob$ in clob default null
, p_clob$_table in dbms_sql.clob_table default empty_clob_table
, p_binary_float$ in binary_float default null
, p_binary_float$_table in dbms_sql.binary_float_table default empty_binary_float_table
, p_binary_double$ in binary_double default null
, p_binary_double$_table in dbms_sql.binary_double_table default empty_binary_double_table
, p_blob$ in blob default null
, p_blob$_table in dbms_sql.blob_table default empty_blob_table
, p_bfile$ in bfile default null
, p_bfile$_table in dbms_sql.bfile_table default empty_bfile_table
, p_date$ in date default null
, p_date$_table in dbms_sql.date_table default empty_date_table
, p_number$ in number default null
, p_number$_table in dbms_sql.number_table default empty_number_table
, p_urowid$ in urowid default null
, p_urowid$_table in dbms_sql.urowid_table default empty_urowid_table
, p_varchar2$ in varchar2 default null
, p_varchar2$_table in dbms_sql.varchar2_table default empty_varchar2_table
, p_timestamp$ in timestamp default null
, p_timestamp$_table in dbms_sql.timestamp_table default empty_timestamp_table
, p_timestamp_ltz$ in timestamp with local time zone default null
, p_timestamp_ltz$_table in dbms_sql.timestamp_with_ltz_table default empty_timestamp_ltz_table
, p_timestamp_tz$ in timestamp with time zone default null
, p_timestamp_tz$_table in dbms_sql.timestamp_with_time_zone_table default empty_timestamp_tz_table
, p_interval_ds$ in interval day to second default null
, p_interval_ds$_table in dbms_sql.interval_day_to_second_table default empty_interval_ds_table
, p_interval_ym$ in interval year to month default null
, p_interval_ym$_table in dbms_sql.interval_year_to_month_table default empty_interval_ym_table
, p_column_value out nocopy column_value_t
);
```


## Procedure construct_statement

Construct the SQL statement.

SIGNATURE

```sql
procedure construct_statement
( p_operation in varchar2
, p_owner in varchar2
, p_table_name in varchar2
, p_statement in varchar2
, p_order_by in varchar2
, p_bind_variable_tab in column_value_tab_t
, p_column_value_tab in out nocopy column_value_tab_t
, p_statement_lines out nocopy dbms_sql.varchar2a
, p_input_column_tab out nocopy column_tab_t
, p_output_column_tab out nocopy column_tab_t
);
```


## Procedure print

Print the column values with a heading using dbug.print().

SIGNATURE

```sql
procedure print
( p_what in varchar2
, p_column_value_tab in column_value_tab_t -- only when an entry exists that table column will be used in the query or DML
);
```


## Procedure print

Print the tables and their column values with a heading using dbug.print().

SIGNATURE

```sql
procedure print
( p_what in varchar2
, p_table_column_value_tab in table_column_value_tab_t -- only when an entry exists that table column will be used in the query or DML
);
```


